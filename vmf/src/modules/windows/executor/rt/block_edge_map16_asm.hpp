/* =============================================================================
 * Vader Modular Fuzzer (VMF)
 * Copyright (c) 2021-2025 The Charles Stark Draper Laboratory, Inc.
 * <vmf@draper.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 (only) as 
 * published by the Free Software Foundation.
 *  
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *  
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *  
 * @license GPL-2.0-only <https://spdx.org/licenses/GPL-2.0-only.html>
 * ===========================================================================*/
 /* 
 * DO NOT EDIT, 
 * 
 * This file is generated by the script mkX8664CodeBytes.py 
 * The 
*/
#include <stdint.h>
#include <cstring>

/** 
 * @brief return ASM code with literal references bound to the variables of getInstance
 *
*/ 
class block_edge_map16_asmGen {
    public:
        /** 
        * @brief size of literal asm byte's abstracted by this class
        */
        static constexpr size_t blockSize = 62;
    protected:
        /** 
        * @brief a parameterized asm block
        */
        static const uint8_t _asmBytes[blockSize];
    public: 
        /** 
        * @brief substitute parameters provided in a copy of the asm bytes
        */
        static void getInstance( uint8_t here[block_edge_map16_asmGen::blockSize], uint64_t prev_pc,uint16_t id,uint64_t map,uint16_t id2 ) {
            uint64_t *prev_pc_set;uint16_t *id_set;uint64_t *map_set;uint16_t *id2_set;
            
            std::memcpy( here, _asmBytes, blockSize );
            prev_pc_set = reinterpret_cast<uint64_t *>(here + 7);
            *prev_pc_set = prev_pc;
            id_set = reinterpret_cast<uint16_t *>(here + 24);
            *id_set = id;
            map_set = reinterpret_cast<uint64_t *>(here + 31);
            *map_set = map;
            id2_set = reinterpret_cast<uint16_t *>(here + 52);
            *id2_set = id2;
        }
};
const uint8_t block_edge_map16_asmGen::_asmBytes[block_edge_map16_asmGen::blockSize] = { 80,159,80,83,81,72,185,0,0,0,0,0,0,0,1,72,15,183,1,72,49,219,102,187,0,1,102,49,216,72,187,0,0,0,0,0,0,0,1,72,1,195,138,3,4,1,20,0,136,3,102,187,0,1,102,137,25,89,91,88,158,88 };
